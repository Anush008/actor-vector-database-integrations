{
  "title": "Pinecone-integration",
  "type": "object",
  "schemaVersion": 1,
  "properties": {
    "pineconeIndexName": {
      "title": "Pinecone index name",
      "type": "string",
      "description": "Name of the Pinecone index where the data will be stored",
      "editor": "textfield"
    },
    "pineconeApiKey": {
      "title": "Pinecone API KEY",
      "description": "Pinecone API KEY",
      "type": "string",
      "editor": "textfield",
      "isSecret": true
    },
    "embeddingsProvider": {
      "title": "Embeddings provider (as defined in the langchain API)",
      "description": "Choose the embeddings provider to use for generating embeddings",
      "type": "string",
      "editor": "select",
      "enum": [
        "OpenAIEmbeddings",
        "CohereEmbeddings"
      ],
      "default": "OpenAIEmbeddings"
    },
    "embeddingsConfig": {
      "title": "Embeddings provider configuration",
      "description": "Specific configuration for the embeddings. For example, for OpenAI, you can the model name as {\"model\": \"text-embedding-ada-002\"})",
      "type": "object",
      "editor": "json"
    },
    "embeddingsApiKey": {
      "title": "Embeddings API KEY (whenever applicable, depends on provider)",
      "description": "Value of the API KEY for the embeddings provider (if required).\n\n For example for OpenAI it is OPENAI_API_KEY, for Cohere it is COHERE_API_KEY)",
      "type": "string",
      "editor": "textfield",
      "isSecret": true
    },
    "datasetFields": {
      "title": "A list of dataset fields which should be selected from the dataset results",
      "type": "array",
      "description": "This array specifies the dataset fields to be selected and stored in the vector store. Only the fields listed here will be included in the vector store. For instance, when using the Website Content Crawler, you might choose to include fields such as `text`, `url`, and `metadata.title` in the vector store.",
      "default": [
        "url",
        "text"
      ],
      "prefill": [
        "url",
        "text",
        "metadata.title"
      ],
      "editor": "stringList"
    },
    "metadataDatasetFields": {
      "title": "A list of dataset fields to be selected from the dataset and stored as metadata in the database",
      "type": "object",
      "description": "A list of dataset fields which should be selected from the dataset and stored as metadata in the vector stores. \n\n For example, when using the Website Content Crawler, you might want to store `url` in metadata. In this case, use `metadataDatasetFields parameter as follows {\"page_url\": \"url\"}`",
      "editor": "json"
    },
    "metadataObject": {
      "title": "Custom object to be stored as metadata in the vector store database",
      "type": "object",
      "description": "This object allows you to store custom metadata for every item in the vector store. For example, if you want to store the `domain` as metadata, use the `metadataObject` like this: {\"domain\": \"apify.com\"}.",
      "editor": "json"
    },
    "performChunking": {
      "title": "Perform chunking",
      "description": "If set to true, the resulting text will be chunked according to the settings below",
      "default": false,
      "type": "boolean"
    },
    "chunkSize": {
      "title": "Chunk size",
      "type": "integer",
      "description": "The maximum character length of each text chunk",
      "default": 1000,
      "minimum": 1
    },
    "chunkOverlap": {
      "title": "Chunk overlap",
      "type": "integer",
      "description": "The character overlap between text chunks that are next to each other",
      "default": 0,
      "minimum": 0
    },
    "cacheEnabled": {
      "title": "Enable caching for subsequent runs",
      "type": "boolean",
      "description": "This setting is applicable for runs following the initial one. When enabled (set to true), the system only adds new content to the vector database and removes orphaned documents, including their vectors. A document is considered orphaned if it hasn't been crawled in subsequent runs and its last seen date exceeds the `orphanedDocAgeLimitDays`. The system internally compares all documents, including their content and metadata, to identify new or orphaned documents.",
      "default": true
    },
    "cacheName": {
      "title": "Cache key name",
      "type": "string",
      "description": "The name of the cache stored in Apify's key-value store. By default, it is set to the actor ID that triggered this integration. The name must be unique for different actors. Do not change this value unless you know what you are doing.",
      "editor": "textfield"
    },
    "datasetKeysToItemId": {
      "title": "Keys for Item Identification",
      "type": "array",
      "items": {
        "type": "string"
      },
      "description": "This array contains keys that are used to uniquely identify items, which helps to handle content changes across different runs. For instance, in a web content crawling scenario, the `url` field could serve as a unique identifier for each item.",
      "editor": "stringList",
      "default": [
        "url"
      ]
    },
    "orphanedDocAgeLimitDays": {
      "title": "Delete orphaned documents older than days limit",
      "type": "number",
      "description": "The number of days after which orphaned documents are deleted from the database.",
      "default": 7,
      "minimum": 0
    },
    "datasetId": {
      "title": "Dataset ID",
      "type": "string",
      "description": "Dataset ID (when running standalone without integration)",
      "editor": "textfield"
    }
  },
  "required": [
    "pineconeIndexName",
    "pineconeApiKey",
    "embeddingsProvider",
    "datasetFields"
  ]
}
